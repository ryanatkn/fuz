import{e as B,a as n,c as fe,t as h}from"./disclose-version.CrWEZmgI.js";import{p as ie,c as s,f as U,g as a,s as e,r as t,t as ee,a as le,an as Y,F as z,n as k,d as A,ao as Se}from"./runtime.CdlCIzqX.js";import{i as M}from"./if.DsxY8x8C.js";import{p as $}from"./proxy.DleyOWho.js";import{C as x}from"./Code.hhPvhWFM.js";import{r as ke,g as xe,d as Ce}from"./theme.svelte.BE-XEXxy.js";import{T as Ie}from"./Tome_Content.DRK-DhLL.js";import{D as ve}from"./Details.DZ-z26VY.js";import{D as be,s as ge}from"./Dialog.BkDkWCiV.js";import{g as ze}from"./tome.C1MEJAP2.js";import{C as Me,T as Pe}from"./Theme_Input.eIU0ldKb.js";import{T as re}from"./Tome_Subheading.BKOfBgK9.js";import{s as ce}from"./render.C75zdlBt.js";import{e as We}from"./each.CGCM_PKh.js";import{s as Ae,a as Be,r as ue,f as _e}from"./attributes.Dh_egPZp.js";import{e as De}from"./utils.EsKM5Bol.js";import{b as Ee}from"./input.Po_9ZA8f.js";import{p as Fe}from"./props.UdRibGWw.js";import{M as ne}from"./Mdn_Link.BfbLe2U9.js";var qe=h('<small class="indicator color_b_5 svelte-rumh1g">copied!</small>'),Ne=h('<small class="indicator color_c_5 svelte-rumh1g">failed</small>'),Oe=h("<button><!><!><!></button>");function Re(g,o){ie(o,!0);let c=Y(!1),v=Y(!1);const m=async l=>{var d,_;z(c,!1),z(v,!1);try{await navigator.clipboard.writeText(o.text)}catch{z(v,!0),(d=o.onclick)==null||d.call(o,null,l);return}z(c,!0),(_=o.onclick)==null||_.call(o,o.text,l)};var u=Oe();let p;var C=s(u);M(C,()=>o.children,l=>{var d=fe(),_=U(d);Ae(_,()=>o.children,()=>a(c),()=>a(v)),n(l,d)},l=>{var d=B("üìã");n(l,d)});var P=e(C);M(P,()=>a(c),l=>{var d=qe();n(l,d)});var S=e(P);M(S,()=>a(v),l=>{var d=Ne();n(l,d)}),t(u),ee(()=>p=Be(u,p,{...o.attrs,type:"button",class:o.classes??(o.children?void 0:"icon_button size_lg"),onclick:m},"svelte-rumh1g")),n(g,u),le()}var Je=h("<blockquote> </blockquote>"),Le=h('<div class="variable svelte-11ggo28"><div class="name svelte-11ggo28"><code> </code></div> <!> <label><div class="title">light</div> <input disabled></label> <label><div class="title">dark</div> <input disabled></label></div>');function je(g,o){ie(o,!0);var c=fe(),v=U(c);M(v,()=>o.variable,m=>{var u=Le(),p=s(u),C=s(p),P=s(C);t(C),t(p);var S=e(p,2);M(S,()=>o.variable.summary,y=>{var T=Je(),D=s(T);t(T),ee(()=>ce(D,o.variable.summary)),n(y,T)});var l=e(S,2),d=e(s(l),2);ue(d),t(l);var _=e(l,2),f=e(s(_),2);ue(f),t(_),t(u),ee(()=>{ce(P,`--${o.variable.name??""}`),_e(d,o.variable.light??""),_e(f,o.variable.dark??"")}),n(m,u)}),n(g,c),le()}const Ye=(g,o,c,v)=>{var m;a(o)&&((m=c.onsave)==null||m.call(c,a(v)))},Ue=g=>{ge(g),alert("TODO")};var Ve=(g,o,c)=>o(g,a(c)),Ge=h('<button type="button" class="variable menu_item svelte-cno0i6"> </button>'),He=h('<div class="copy svelte-cno0i6"><!></div> <!>',1),Ke=h('<div class="pane"><div class="panel p_lg box"><!> <aside>‚ö†Ô∏è This is unfinished and will change.</aside> <button type="button">ok</button></div></div>'),Qe=h('<div class="theme_form svelte-cno0i6"><h2 class="text_align_center"><!> theme</h2> <aside>‚ö†Ô∏è Creating and editing themes at runtime is a work in progress i.e. totally unfinished.</aside> <header class="svelte-cno0i6"><div class="variables_header svelte-cno0i6"><p> </p> <button type="button" class="w_100" disabled>add a variable</button></div> <form class="svelte-cno0i6"><label><div class="title">name</div> <input placeholder=">"></label> <button type="button"><!></button></form></header> <div class="content svelte-cno0i6"><div class="variables svelte-cno0i6"></div> <div class="rendered svelte-cno0i6"><!></div></div></div> <!>',1);function Xe(g,o){ie(o,!0);const c=Fe(o,"theme",3,null);let v=Y($(c()?c().name:"new theme")),m=Y($(c()?c().variables:[]));const u=A(()=>({name:a(v),variables:a(m)})),p=A(()=>ke(a(u),{empty_default_theme:!1,specificity:1})),C=A(()=>a(m).reduce((r,i)=>i.light?r+1:r,0)),P=A(()=>a(m).reduce((r,i)=>i.dark?r+1:r,0));let S=Y(null);const l=(r,i)=>{ge(r),z(S,$(i)),z(m,$(a(m).slice()))},d=A(()=>!!c()),_=A(()=>c()?a(v)!==c().name||a(m)!==c().variables:!0);var f=Qe(),y=U(f),T=s(y),D=s(T);M(D,()=>a(d),r=>{var i=B("edit");n(r,i)},r=>{var i=B("create");n(r,i)}),k(),t(T);var N=e(T,4),O=s(N),R=s(O),de=s(R);t(R);var V=e(R,2);V.__click=[Ue],t(O);var G=e(O,2),E=s(G),H=e(s(E),2);ue(H),t(E);var J=e(E,2);J.__click=[Ye,_,o,u];var te=s(J);M(te,()=>a(d),r=>{var i=B("save changes");n(r,i)},r=>{var i=B("create theme");n(r,i)}),t(J),t(G),t(N);var K=e(N,2),L=s(K);We(L,21,()=>a(m),r=>r.name,(r,i)=>{var b=Ge();b.__click=[Ve,l,i];var F=s(b);t(b),ee(()=>ce(F,`--${a(i).name??""}`)),n(r,b)}),t(L);var Q=e(L,2),me=s(Q);M(me,()=>a(p),r=>{var i=He(),b=U(i),F=s(b);Re(F,{get text(){return a(p)}}),t(b);var W=e(b,2);x(W,{get content(){return a(p)},lang:"css"}),n(r,i)}),t(Q),t(K),t(y);var he=e(y,2);M(he,()=>a(S),r=>{be(r,{onclose:()=>z(S,null),children:(b,F=Se)=>{var W=Ke(),X=s(W),Z=s(X);je(Z,{get variable(){return a(S)}});var oe=e(Z,4);oe.__click=function(...ae){var se;(se=F())==null||se.apply(this,ae)},t(X),t(W),n(b,W)}})}),ee(()=>{ce(de,`variables: ${a(C)??""} light, ${a(P)??""} dark`),J.disabled=!a(_)}),Ee(H,()=>a(v),r=>z(v,r)),n(g,f),le()}De(["click"]);var Ze=h(`<aside><p>Most theme usage affects the whole page, so Fuz makes that easy.</p> <p>By default <code>Themed</code> syncs its settings to the global <code>:root</code> tag and
					persists to <code>localStorage</code>.</p> <p>These behaviors can be customized with its props:</p> <ul><li><code>sync_color_scheme</code></li> <li><code>load_color_scheme</code></li> <li><code>save_color_scheme</code></li> <li><code>load_theme</code></li> <li><code>save_theme</code></li></ul> <p>A feature to support partial page theming is planned with <code>Themed_Scope</code>.</p></aside>`),$e=h(`<aside><p><code>Themed</code> is designed to wrap every page at the top level so it can provide the
					selected theme and color scheme in the Svelte context via a <code>themer</code> instance.
					It works without children, but <code>get_themer</code> will fail unless you call <code>set_themer</code> yourself.</p> <p>This lets you call <code>get_themer</code> to access the reactive <code>Themer</code> class instance anywhere in your code. The helper components on this page like <code>Color_Scheme_Input</code> and <code>Theme_Input</code> use it so they don't require
					a <code>themer</code> prop.</p> <p>If you don't don't want to wrap everything in <code>Themed</code> for some reason, you can
					set a <code>Themer</code> in context manually. It must be the same reference as the <code>Themed</code> prop:</p> <!></aside>`),et=h("More about <code>Color_Scheme_Input</code>",1),tt=h(`<aside><p><code>Color_Scheme_Input</code> enables users to choose and persist the color scheme without
					boilerplate.</p> <p>By default, <code>Color_Scheme_Input</code> works with <code>Themed</code>'s <code>themer</code> in context to save the user's preference to <code>localStorage</code>.
					To customize this behavior, pass your own <code>value</code> or <code>onchange</code> props. The <code>value</code> defaults to <code>get_themer()</code> so technically you
					could call <code>set_themer</code>, but it's unlikely you want to override it in context.</p></aside>`),ot=h(`<section class="theme"><p>Fuz provides UI components that use <a href="https://moss.ryanatkn.com/library/themes">Moss' theming system</a> for dark mode and custom themes.</p> <p><code>Themed</code> adds global support for both the browser's <!> and custom themes based on <a href="https://moss.ryanatkn.com/library/variables">Moss style variables</a>, which use <!>. <code>Themed</code> is a singleton component that's mounted at the top-level of the page:</p> <!> <!> <!> <!></section> <section class="theme"><!> <p><code>Themed</code> defaults to automatic <!> detection with <!>, and users can also set it directly:</p> <!> <!> <!> <p>Pass props to override the default:</p> <!> <p>The builtin themes support both dark and light color schemes. Custom themes may support one or
			both color schemes.</p> <!></section> <section class="theme"><!> <p>A theme is a simple JSON collection of <a href="https://moss.ryanatkn.com/library/variables">Moss style variables</a> that can be transformed into CSS that set custom properties. Each variable can have values for
			light and/or dark color schemes. In other words, "dark" isn't a theme, it's a mode that any theme
			can implement.</p> <div class="width_sm mb_lg"><!></div> <aside>‚ö†Ô∏è The builtin themes need a lot more work, but the proof of concept seems to work.</aside> <aside>‚ö†Ô∏è Custom themes currently pop in on page load. To see this, change from the base theme and
			refresh the page. This can be fixed using a similar strategy that we use to avoid pop-in of
			user-defined color schemes, but it's more involved.</aside></section> <section class="theme"><!> <p>Themes are plain CSS that can be sourced in a variety of ways.</p> <p>To use Fuz's base theme:</p> <!> <p><code>Themed</code> can be customized with the the nonreactive prop <code>themer</code>:</p> <!> <!> <aside>The <code>themer</code> prop is not reactive because it's put in Svelte context without a wrapper.
			This could be fixed, let me know if you have a usecase.</aside> <p><code>Themed</code> sets the <code>themer</code> in the Svelte context:</p> <!> <p>For a more complete example, see <a href="https://github.com/ryanatkn/fuz_template">fuz_template</a>.</p></section> <section><!> <p><code>Themed</code> initializes the system's theme support. Without it, the page will not
			reflect the user's system <code>color-scheme</code>. By default, <code>Themed</code> applies the base theme to the root
			of the page via <code>create_theme_setup_script</code>. It uses JS to add the <code>.dark</code> CSS class to the <code>:root</code> element.</p> <p>This strategy enables color scheme and theme support with minimal CSS and optimal performance
			for most use cases. The system supports plain CSS usage that can be static or dynamic, or
			imported at buildtime or runtime. It also allows runtime access to the underlying data like
			the <a href="https://moss.ryanatkn.com/library/variables">style variables</a> if you want to pay
			the performance costs. Scoped theming to one part of the page is planned.</p> <p>The theme setup script interacts with <code>sync_color_scheme</code> to save the user's
			preference to <code>localStorage</code>. See also <code>Color_Scheme_Input</code>.</p> <p>The setup script avoids flash-on-load due to color scheme, but currently themes flash in after
			loading. We'll try to fix this when the system stabilizes.</p></section>`,1),at=h('<div class="pane"><div class="theme_editor_wrapper panel svelte-1io66l"><!></div></div>'),st=h("<!>  <!>",1);function kt(g,o){ie(o,!0);const v=ze("Themed"),m=Ce.slice(),u=xe();let p=Y(null);var C=st(),P=U(C);Ie(P,{tome:v,children:(l,d)=>{var _=ot(),f=U(_),y=e(s(f),2),T=e(s(y),2);ne(T,{path:"Web/CSS/color-scheme"});var D=e(T,4);ne(D,{path:"Web/CSS/--*",children:(j,w)=>{k();var I=B("CSS custom properties");n(j,I)},$$slots:{default:!0}}),k(3),t(y);var N=e(y,2);x(N,{content:"import Themed from '@ryanatkn/fuz/Themed.svelte';",lang:"ts"});var O=e(N,2);x(O,{content:`<!-- +layout.svelte -->
<Themed>
	{@render children()}
</Themed>`});var R=e(O,2);ve(R,{summary:w=>{k();var I=B("Why the singleton?");n(w,I)},children:(w,I)=>{var q=Ze();n(w,q)},$$slots:{default:!0}});var de=e(R,2);ve(de,{summary:w=>{k();var I=B("Why nested children?");n(w,I)},children:(w,I)=>{var q=$e(),we=e(s(q),6);x(we,{content:`<script>
	const themer = new Themer(...);
	set_themer(themer);
<\/script>
<Themed {themer} />
<!--
	sibling components not nested in \`Themed\`
	can now call \`get_themer\`
-->`}),t(q),n(w,q)},$$slots:{default:!0}}),t(f);var V=e(f,2),G=s(V);re(G,{text:"Color scheme",slug:"color-scheme"});var E=e(G,2),H=e(s(E),2);ne(H,{path:"Web/CSS/color-scheme"});var J=e(H,2);ne(J,{path:"Web/CSS/@media/prefers-color-scheme"}),k(),t(E);var te=e(E,2);Me(te,{});var K=e(te,2);x(K,{content:"import Color_Scheme_Input from '@ryanatkn/fuz/Color_Scheme_Input.svelte';",lang:"ts"});var L=e(K,2);x(L,{content:"<Color_Scheme_Input />"});var Q=e(L,4),me=A(()=>`<Color_Scheme_Input
	value={{color_scheme: ${"'"+JSON.stringify(u.color_scheme).replace(/"/g,"")+"'"}}}
	onchange={...}
/>`);x(Q,{get content(){return a(me)}});var he=e(Q,4);ve(he,{summary:w=>{k();var I=et();k(),n(w,I)},children:(w,I)=>{var q=tt();n(w,q)},$$slots:{default:!0}}),t(V);var r=e(V,2),i=s(r);re(i,{text:"Builtin themes",slug:"builtin-themes"});var b=e(i,4),F=s(b);Pe(F,{themes:m,enable_editing:!0,onedit:j=>z(p,$(j))}),t(b),k(4),t(r);var W=e(r,2),X=s(W);re(X,{text:"Example usage",slug:"example-usage"});var Z=e(X,6);x(Z,{content:`<!-- +layout.svelte -->
<script>
	import '@ryanatkn/moss/style.css';
	import '@ryanatkn/moss/theme.css';
	import Themed from '@ryanatkn/fuz/Themed.svelte';
	import type {Snippet} from 'svelte';

	interface Props {
		children: Snippet;
	}
	
	const {children}: Props = $props();
<script>

<!-- enable theme and color-scheme support -->
<Themed>
	{@render children()}
</Themed>`});var oe=e(Z,4);x(oe,{content:`import {Themer} from '@ryanatkn/fuz/theme.svelte.js';
const themer = new Themer(...);`,lang:"ts"});var ae=e(oe,2);x(ae,{content:`<Themed {themer}>
	{@render children()}
</Themed>`});var se=e(ae,6),ye=A(()=>`// get values from the Svelte context provided by
// the nearest \`Themed\` ancestor:
import {get_themer} from '@ryanatkn/fuz/theme.js';
const themer = get_themer();
themer.theme.name; // '${u.theme.name}'
themer.color_scheme; // '${u.color_scheme}'`);x(se,{get content(){return a(ye)},lang:"ts"}),k(2),t(W);var pe=e(W,2),Te=s(pe);re(Te,{text:"More details",slug:"more-details"}),k(8),t(pe),n(l,_)},$$slots:{default:!0}});var S=e(P,2);M(S,()=>a(p),l=>{be(l,{onclose:()=>z(p,null),children:(d,_)=>{var f=at(),y=s(f),T=s(y);Xe(T,{get theme(){return a(p)},onsave:D=>{console.log("update theme",D),alert("todo")}}),t(y),t(f),n(d,f)},$$slots:{default:!0}})}),n(g,C),le()}export{je as S,kt as _};
