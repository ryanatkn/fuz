/**
 * Svelte component analysis helpers using svelte2tsx
 *
 * Provides utilities for extracting metadata from Svelte components:
 * - Component props with types and JSDoc
 * - Component-level documentation
 * - Type information from TypeScript
 */

import ts from 'typescript';
import type {Enhanced_Declaration, Component_Prop_Info} from './enhanced_declarations.js';
import {extract_jsdoc} from './ts_helpers.js';

/**
 * Analyze a Svelte component from its TSX transformation
 *
 * @param tsx_code - The TSX code generated by svelte2tsx
 * @param source_file - Original .svelte source file
 * @param checker - TypeScript type checker
 * @param component_name - Name of the component (derived from filename)
 * @returns Enhanced declaration with component metadata
 */
export const analyze_svelte_component = (
	tsx_code: string,
	source_file: ts.SourceFile,
	checker: ts.TypeChecker,
	component_name: string,
): Enhanced_Declaration => {
	const enhanced: Enhanced_Declaration = {
		name: component_name,
		kind: 'component',
	};

	try {
		// Create a virtual source file from the TSX code
		const virtual_source = ts.createSourceFile(
			source_file.fileName + '.tsx',
			tsx_code,
			ts.ScriptTarget.Latest,
			true,
			ts.ScriptKind.TSX,
		);

		// Extract component-level JSDoc from original source
		const component_jsdoc = extract_component_jsdoc(source_file);
		if (component_jsdoc) {
			enhanced.doc_comment = component_jsdoc.full_text;
			enhanced.summary = component_jsdoc.summary;
			enhanced.examples = component_jsdoc.examples;
			enhanced.deprecated_message = component_jsdoc.deprecated_message;
			enhanced.see_also = component_jsdoc.see_also;
		}

		// Extract props from Props interface
		const props = extract_props_from_tsx(virtual_source, checker);
		if (props.length > 0) {
			enhanced.props = props;
		}

		// Extract source location from original file
		const start_pos = source_file.getLineAndCharacterOfPosition(0);
		const end_pos = source_file.getLineAndCharacterOfPosition(source_file.end);
		enhanced.source_location = {
			line: start_pos.line + 1,
			column: start_pos.character,
			end_line: end_pos.line + 1,
			end_column: end_pos.character,
		};

		enhanced.exported = true; // Components are always exported
	} catch (err) {
		// If analysis fails, return basic component info
		console.error(`Error analyzing Svelte component ${component_name}:`, err);
	}

	return enhanced;
};

/**
 * Extract component-level JSDoc comment from Svelte source
 */
const extract_component_jsdoc = (
	source_file: ts.SourceFile,
):
	| {
			full_text: string;
			summary: string;
			examples: Array<string>;
			deprecated_message?: string;
			see_also: Array<string>;
	  }
	| undefined => {
	// Look for JSDoc comments before <script> tag or at the start of the file
	const full_text = source_file.getFullText();
	const leading_comments = ts.getLeadingCommentRanges(full_text, 0);
	if (!leading_comments?.length) return undefined;

	let doc_text = '';
	const examples: Array<string> = [];
	let deprecated_message: string | undefined;
	const see_also: Array<string> = [];

	for (const comment of leading_comments) {
		let text = full_text.substring(comment.pos, comment.end);

		// Clean comment markers
		text = text
			.replace(/^\/\*\*/, '')
			.replace(/\*\/$/, '')
			.replace(/^\/\//, '')
			.split('\n')
			.map((line) => line.replace(/^\s*\*\s?/, '').trim())
			.join('\n')
			.trim();

		doc_text += text + '\n';

		// Extract @example, @deprecated, @see tags
		const example_match = text.match(/@example\s+([\s\S]+?)(?=\n@|\n\n|$)/g);
		if (example_match) {
			for (const match of example_match) {
				examples.push(match.replace(/@example\s+/, '').trim());
			}
		}

		const deprecated_match = text.match(/@deprecated\s+(.+)/);
		if (deprecated_match) {
			deprecated_message = deprecated_match[1]!.trim();
		}

		const see_match = text.match(/@see\s+(.+)/g);
		if (see_match) {
			for (const match of see_match) {
				see_also.push(match.replace(/@see\s+/, '').trim());
			}
		}
	}

	doc_text = doc_text.trim();
	if (!doc_text) return undefined;

	const summary = doc_text.split('\n\n')[0]!.trim();

	return {full_text: doc_text, summary, examples, deprecated_message, see_also};
};

/**
 * Extract props from Props interface in TSX
 */
const extract_props_from_tsx = (
	virtual_source: ts.SourceFile,
	checker: ts.TypeChecker,
): Array<Component_Prop_Info> => {
	const props: Array<Component_Prop_Info> = [];

	// Find the Props interface
	ts.forEachChild(virtual_source, (node) => {
		if (ts.isInterfaceDeclaration(node) && node.name.text === 'Props') {
			// Iterate through interface members
			for (const member of node.members) {
				if (ts.isPropertySignature(member) && ts.isIdentifier(member.name)) {
					const prop_name = member.name.text;
					const optional = !!member.questionToken;

					// Get type string
					let type_string = 'any';
					if (member.type) {
						type_string = member.type.getText(virtual_source);
					} else {
						// Try to get type from type checker
						try {
							const prop_type = checker.getTypeAtLocation(member);
							type_string = checker.typeToString(prop_type);
						} catch {
							// Fallback to 'any'
						}
					}

					// Extract JSDoc description
					let description: string | undefined;
					const jsdoc = extract_jsdoc(member, virtual_source);
					if (jsdoc) {
						description = jsdoc.summary || jsdoc.full_text;
					}

					// Extract default value (if available in JSDoc or initializer)
					let default_value: string | undefined;
					const default_match = description?.match(/@default\s+(.+)/);
					if (default_match) {
						default_value = default_match[1]!.trim();
					}

					props.push({
						name: prop_name,
						type: type_string,
						optional,
						description,
						default_value,
					});
				}
			}
		}
	});

	return props;
};
