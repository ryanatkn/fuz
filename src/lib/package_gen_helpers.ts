/**
 * Build-time helpers for package metadata generation.
 *
 * These functions handle Gro-specific concerns like file collection and dependency
 * graph extraction. Core analysis logic has been extracted to reusable helpers:
 *
 * - `ts_helpers.ts` - `ts_analyze_module_exports`
 * - `svelte_helpers.ts` - `svelte_analyze_file`
 * - `module_helpers.ts` - path utilities and source detection
 *
 * Design philosophy: Fail fast with clear errors rather than silently producing invalid
 * metadata. All validation errors halt the build immediately with actionable messages.
 *
 * @see package.gen.ts for the main generation task
 * @see @ryanatkn/belt/src_json.js for type definitions
 * @see ts_helpers.ts for reusable TypeScript analysis
 * @see svelte_helpers.ts for reusable Svelte component analysis
 */

import type {PackageJson} from '@ryanatkn/belt/package_json.js';
import type {Logger} from '@ryanatkn/belt/log.js';
import type {ModuleJson, SrcJson} from '@ryanatkn/belt/src_json.js';
import type {Disknode} from '@ryanatkn/gro/disknode.js';
import type ts from 'typescript';
import type {PathId} from '@ryanatkn/belt/path.js';

import {ts_analyze_module_exports, type ReExportInfo} from './ts_helpers.js';
import {svelte_analyze_file} from './svelte_helpers.js';
import {
	module_extract_path,
	module_is_typescript,
	module_is_svelte,
	module_matches_source,
} from './module_helpers.js';

/**
 * Result of analyzing a TypeScript file.
 * Includes both the module metadata and re-export information for post-processing.
 */
export interface TsFileAnalysis {
	/** Module metadata for inclusion in src_json. */
	module: ModuleJson;
	/** Re-exports from this module for building also_exported_from. */
	re_exports: Array<ReExportInfo>;
}

/**
 * Validates that no identifier names are duplicated across modules.
 * The flat namespace is intentional - duplicates should fail fast.
 *
 * @throws Error if duplicate identifier names are found
 */
export const package_gen_validate_no_duplicates = (src_json: SrcJson, log: Logger): void => {
	const identifier_locations: Map<string, Array<{module: string; kind: string}>> = new Map();

	// Collect all identifier names and their locations
	for (const mod of src_json.modules ?? []) {
		for (const identifier of mod.identifiers ?? []) {
			const name = identifier.name;
			if (!identifier_locations.has(name)) {
				identifier_locations.set(name, []);
			}
			identifier_locations.get(name)!.push({
				module: mod.path,
				kind: identifier.kind,
			});
		}
	}

	// Check for duplicates
	const duplicates: Array<{name: string; locations: Array<{module: string; kind: string}>}> = [];
	for (const [name, locations] of identifier_locations.entries()) {
		if (locations.length > 1) {
			duplicates.push({name, locations});
		}
	}

	if (duplicates.length > 0) {
		log.error('Duplicate identifier names detected in flat namespace:');
		for (const {name, locations} of duplicates) {
			log.error(`  "${name}" found in:`);
			for (const {module, kind} of locations) {
				log.error(`    - ${module} (${kind})`);
			}
		}
		throw new Error(
			`Found ${duplicates.length} duplicate identifier name${duplicates.length === 1 ? '' : 's'} across modules. ` +
				'The flat namespace requires unique names. To resolve: ' +
				'(1) rename one of the conflicting identifiers, or ' +
				'(2) add /** @nodocs */ to exclude from documentation. ' +
				'See CLAUDE.md "Identifier namespacing" section for details.',
		);
	}
};

/**
 * Sort modules alphabetically by path for deterministic output and cleaner diffs.
 */
export const package_gen_sort_modules = (modules: Array<ModuleJson>): Array<ModuleJson> => {
	return modules.slice().sort((a, b) => a.path.localeCompare(b.path));
};

/**
 * Generate the package.ts file content with package_json and src_json exports.
 */
export const package_gen_generate_ts = (package_json: PackageJson, src_json: SrcJson): string => {
	const is_this_belt = package_json.name === '@ryanatkn/belt';
	const banner = `// generated by package.gen.ts !! do not edit directly or risk lost data`;
	return `${banner}

import type {PackageJson} from '${is_this_belt ? './package_json.js' : '@ryanatkn/belt/package_json.js'}';
import type {SrcJson} from '${is_this_belt ? './src_json.js' : '@ryanatkn/belt/src_json.js'}';

export const package_json: PackageJson = ${stringify(package_json)};

export const src_json: SrcJson = ${stringify(src_json)};

${banner}
`;
};

const stringify = (v: unknown): string => JSON.stringify(v, null, '\t');

/**
 * Collect and filter source files from filer.
 *
 * Returns disknodes for TypeScript/JS files and Svelte components from src/lib, excluding test files.
 * Returns an empty array with a warning if no source files are found.
 */
export const package_gen_collect_source_files = (
	files: Map<PathId, Disknode>,
	log: Logger,
): Array<Disknode> => {
	log.info(`filer has ${files.size} files total`);

	const source_disknodes: Array<Disknode> = [];
	for (const [id, disknode] of files.entries()) {
		if (module_matches_source(id)) {
			// Include TypeScript/JS files and Svelte components
			if (module_is_typescript(id) || module_is_svelte(id)) {
				source_disknodes.push(disknode);
			}
		}
	}

	log.info(`found ${source_disknodes.length} source files to analyze`);

	if (source_disknodes.length === 0) {
		log.warn('No source files found in src/lib - generating empty package metadata');
		return [];
	}

	// Sort for deterministic output (stable alphabetical module ordering)
	source_disknodes.sort((a, b) => a.id.localeCompare(b.id));

	return source_disknodes;
};

/**
 * Analyze a Svelte component file and extract metadata.
 *
 * Uses `svelte_analyze_file` for core analysis, then adds
 * Gro-specific dependency information from the disknode.
 */
export const package_gen_analyze_svelte_file = (
	disknode: Disknode,
	module_path: string,
	checker: ts.TypeChecker,
): ModuleJson => {
	// Use the extracted helper for core analysis
	const identifier_json = svelte_analyze_file(disknode.id, module_path, checker);

	// Extract dependencies and dependents (Gro-specific)
	const {dependencies, dependents} = package_gen_extract_dependencies(disknode);

	return {
		path: module_path,
		identifiers: [identifier_json],
		dependencies: dependencies.length > 0 ? dependencies : undefined,
		dependents: dependents.length > 0 ? dependents : undefined,
	};
};

/**
 * Analyze a TypeScript file and extract all identifiers.
 *
 * Uses `ts_analyze_module_exports` for core analysis, then adds
 * Gro-specific dependency information from the disknode.
 *
 * Returns both the module metadata and re-export information for post-processing.
 */
export const package_gen_analyze_typescript_file = (
	disknode: Disknode,
	source_file: ts.SourceFile,
	module_path: string,
	checker: ts.TypeChecker,
): TsFileAnalysis => {
	// Use the extracted helper for core analysis
	const {module_comment, identifiers, re_exports} = ts_analyze_module_exports(source_file, checker);

	const mod: ModuleJson = {
		path: module_path,
		identifiers,
	};

	if (module_comment) {
		mod.module_comment = module_comment;
	}

	// Extract dependencies and dependents (Gro-specific)
	const {dependencies, dependents} = package_gen_extract_dependencies(disknode);
	if (dependencies.length > 0) {
		mod.dependencies = dependencies;
	}
	if (dependents.length > 0) {
		mod.dependents = dependents;
	}

	return {module: mod, re_exports};
};

/**
 * Extract dependencies and dependents for a module from the filer's dependency graph.
 *
 * Filters to only include source modules from src/lib (excludes external packages, node_modules, tests).
 * Returns sorted arrays of module paths (relative to src/lib) for deterministic output.
 */
export const package_gen_extract_dependencies = (
	disknode: Disknode,
): {dependencies: Array<string>; dependents: Array<string>} => {
	const dependencies: Array<string> = [];
	const dependents: Array<string> = [];

	// Extract dependencies (files this module imports)
	for (const dep_id of disknode.dependencies.keys()) {
		if (module_matches_source(dep_id)) {
			dependencies.push(module_extract_path(dep_id));
		}
	}

	// Extract dependents (files that import this module)
	for (const dependent_id of disknode.dependents.keys()) {
		if (module_matches_source(dependent_id)) {
			dependents.push(module_extract_path(dependent_id));
		}
	}

	// Sort for deterministic output
	dependencies.sort();
	dependents.sort();

	return {dependencies, dependents};
};
